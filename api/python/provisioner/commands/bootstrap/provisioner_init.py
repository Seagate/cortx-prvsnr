#
# Copyright (c) 2020 Seagate Technology LLC and/or its Affiliates
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
# For any questions about this software or licensing,
# please email opensource@seagate.com or cortx-questions@seagate.com.
#

import logging
from typing import Dict, Optional
from provisioner import (
    inputs,
    config,
    utils
)
from . import (
    Node
)
from provisioner.vendor import attr
from provisioner.salt import SaltSSHClient
from pathlib import Path


logger = logging.getLogger(__name__)


# TODO TEST EOS-8473
class RunArgsSetup:
    name: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': (
                    "A name to assign to the setup profile, "
                    "auto-generated by default"
                ),
            }
        },
        default=None
    )
    config_path: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': (
                    "config.ini file path to update salt data "
                ),
            }
        },
        default=None
    )
    profile: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': (
                    "the path to the setup profile directory, "
                    "auto-generated inside current directory "
                    "by default, if specified '--name' option is ignored"
                )
            }
        },
        default=None,
        converter=(lambda v: Path(str(v)) if v else v)
    )
    prvsnr_version: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "Provisioner version to setup",
            }
        },
        default=None
    )
    bootstrap_key: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "bootstrap key for initial access",
                'metavar': 'PATH'
            }
        },
        default=None,
        converter=(lambda v: Path(str(v)) if v else v),
        validator=utils.validator_path_exists
    )
    source: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "the source for provisioner repo installation",
                'choices': ['local', 'gitrepo', 'rpm', 'iso']
            }
        },
        default='rpm'
    )
    # TODO EOS-12076 validate it is a dir
    local_repo: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "the path to local provisioner repo",
                'metavar': 'PATH'
            }
        },
        default=config.PROJECT_PATH,
        converter=utils.converter_path_resolved,
        validator=utils.validator_path_exists
    )
    iso_os: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "the path to a OS ISO",
                'metavar': 'PATH'
            }
        },
        default=None,
        converter=utils.converter_path_resolved,
        validator=utils.validator_path_exists
    )
    # TODO EOS-12076 validate it is a file
    iso_cortx: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "the path to a CORTX ISO",
                'metavar': 'PATH'
            }
        },
        default=None,
        converter=utils.converter_path_resolved,
        validator=utils.validator_path_exists
    )
    # TODO EOS-12076 validate it is a file
    iso_cortx_deps: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "the path to a CORTX dependencies ISO",
                'metavar': 'PATH'
            }
        },
        default=None,
        converter=utils.converter_path_resolved,
        validator=utils.validator_path_exists
    )
    # FIXME EOS-13651, EOS-13686 disabled until code complete
    # url_cortx_deps: str = attr.ib(
    #    metadata={
    #        inputs.METADATA_ARGPARSER: {
    #            'help': "Bundled CORTX dependencies url"
    #        }
    #    },
    #    default=None
    # )
    dist_type: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "the type of the distribution",
                'choices': [dt.value for dt in config.DistrType]
            }
        },
        default=config.DistrType.CORTX.value,
        # TODO EOS-12076 better validation
        converter=(lambda v: config.DistrType(v))
    )
    target_build: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': (
                    "Cortex integration release version repo URL/path."
                    "[This feature is Seagate internal only.]"
                ),
                # 'help': (
                #     "Cortex integration release version relative to "
                #     f"{config.CORTX_REPOS_BASE_URL}"
                # ),
            }
        },
        default=None
        # default='github/release/rhel-7.7.1908/last_successful',
        # converter=(lambda v: f'{config.CORTX_REPOS_BASE_URL}/{v}')
    )
    pypi_repo: bool = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': (
                    "Use pypi.org as source for pip installations"
                ),
            }
        },
        default=False
    )
    ha: bool = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "turn on high availability setup",
            }
        },
        default=False
    )
    glusterfs_docker: bool = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "configure Dockerized glusterfs servers",
            }
        },
        default=False
    )
    field_setup: bool = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "turn on field setup mode",
            }
        },
        default=False
    )
    salt_master: str = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "domain name or IP of the salt-master"
            }
        },
        default=None
    )
    update: bool = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': (
                            "update initial configuration "
                            "[not to be used in production environments "
                            "as it resets grains data]"
                        ),
            }
        },
        default=False
    )
    rediscover: bool = attr.ib(
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': "update host related configuration and connections",
            }
        },
        default=False
    )


# TODO TEST EOS-8473
@attr.s(auto_attribs=True)
class RunArgsSetupProvisionerBase:
    name: str = RunArgsSetup.name
    config_path: str = RunArgsSetup.config_path
    profile: str = RunArgsSetup.profile
    source: str = RunArgsSetup.source
    bootstrap_key: str = RunArgsSetup.bootstrap_key
    prvsnr_version: str = RunArgsSetup.prvsnr_version
    local_repo: str = RunArgsSetup.local_repo
    iso_os: str = RunArgsSetup.iso_os
    iso_cortx: str = RunArgsSetup.iso_cortx
    iso_cortx_deps: str = RunArgsSetup.iso_cortx_deps
    # FIXME url_cortx_deps: str = RunArgsSetup.url_cortx_deps
    url_cortx_deps: str = attr.ib(init=False, default=None)
    dist_type: str = RunArgsSetup.dist_type
    target_build: str = RunArgsSetup.target_build
    pypi_repo: bool = RunArgsSetup.pypi_repo
    salt_master: str = RunArgsSetup.salt_master
    update: bool = RunArgsSetup.update
    rediscover: bool = RunArgsSetup.rediscover
    field_setup: bool = RunArgsSetup.field_setup


@attr.s(auto_attribs=True)
class RunArgsSetupProvisionerGeneric(RunArgsSetupProvisionerBase):
    ha: bool = RunArgsSetup.ha
    glusterfs_docker: bool = RunArgsSetup.glusterfs_docker
    nodes: str = attr.ib(
        kw_only=True,
        metadata={
            inputs.METADATA_ARGPARSER: {
                'help': (
                    "cluster node specification, "
                    "format: id:[user@]hostname[:port]"
                ),
                'nargs': '+'
            }
        },
        converter=(
            lambda specs: [
                (s if isinstance(s, Node) else Node.from_spec(s))
                for s in specs
            ]
        )
    )

    @property
    def primary(self):
        return self.nodes[0]

    @property
    def secondaries(self):
        return self.nodes[1:]

    def __attrs_post_init__(self):  # noqa: C901
        # TODO review params check logic per dist type
        logger.debug(f"Provisioner setup Source is: '{self.source}'")

        # check sources
        if self.source == 'local':
            if not self.local_repo:
                raise ValueError("local repo is undefined")
            if (
                not self.pypi_repo and
                self.dist_type != config.DistrType.BUNDLE
            ):
                logger.warning(
                    "Custom pip repo cannot be used "
                    "for non bundled distributions "
                    "hence pip will be configured to install from pypi.org "
                )
                self.pypi_repo = True
        elif self.source == 'iso':
            if not self.iso_cortx:
                raise ValueError("ISO for CORTX is undefined")

            iso_names = []
            if self.iso_os:
                if self.iso_os.suffix != '.iso':
                    raise ValueError(
                        ".iso extension is expected for OS ISO"
                    )
                iso_names.append(self.iso_os.name)

            if self.iso_cortx.suffix != '.iso':
                raise ValueError(".iso extension is expected for CORTX ISO")
            iso_names.append(self.iso_cortx.name)

            if self.iso_cortx_deps:
                if self.iso_cortx_deps.suffix != '.iso':
                    raise ValueError(
                        ".iso extension is expected for CORTX deps ISO"
                    )
                if not self.pypi_repo:
                    logger.warning(
                        "Custom python repo can be used only "
                        "for single ISO based setup "
                        "hence pip will be configured to install from pypi.org"
                    )
                    self.pypi_repo = True
                iso_names.append(self.iso_cortx_deps.name)

            if len(iso_names) != len(set(iso_names)):
                raise ValueError(
                    "ISO files have collision in names"
                )

            if self.dist_type != config.DistrType.BUNDLE:
                logger.info(
                    "The type of distribution would be set to "
                    f"{config.DistrType.BUNDLE}"
                )
                self.dist_type = config.DistrType.BUNDLE

            if (
                self.target_build !=
                attr.fields(type(self)).target_build.default
            ):
                logger.warning(
                    "`target_build` value would be ignored "
                    "for ISO based installation"
                )

            release_sls = (
                config.BUNDLED_SALT_PILLAR_DIR / 'groups/all/release.sls'
            )
            # iso files will be mounted into dirs inside that directory
            base_dir = Path(
                utils.load_yaml(release_sls)['release']['base']['base_dir']
            )

            if not self.iso_cortx_deps:
                base_dir /= config.CORTX_SINGLE_ISO_DIR

            self.target_build = f'file://{base_dir}'

            if (
                self.url_cortx_deps !=
                attr.fields(type(self)).url_cortx_deps.default
            ):
                logger.warning(
                    "`url_cortx_deps` value would be ignored "
                    "for ISO based installation"
                )
                self.url_cortx_deps = None

        elif self.source == 'rpm':
            if not self.target_build:
                raise ValueError('`target_build` should be specified')
            if self.dist_type == config.DistrType.BUNDLE and (
                self.url_cortx_deps !=
                attr.fields(type(self)).url_cortx_deps.default
            ):
                logger.warning(
                    "`url_cortx_deps` value would be ignored "
                    "for bundle distribution type"
                )
                self.url_cortx_deps = None
            if (
                not self.pypi_repo and
                self.dist_type != config.DistrType.BUNDLE
            ):
                logger.warning(
                    "Custom pip repo cannot be used "
                    "for non bundled distributions "
                    "hence pip will be configured to install from pypi.org"
                )
                self.pypi_repo = True
        else:
            logger.error(
                "Invalid or Unsupported Provisioner source "
                f"{self.source} provided for deployment"
            )
            raise NotImplementedError(
                f"{self.source} provisioner source is not supported yet"
            )

        # TODO EOS-18920 Validation for all run_args
        # Cumulate all checks and exceptions related to
        # input cmd args in a single method

        if len(self.nodes) < 2 and self.ha:
            raise ValueError(
                'HA is supported only for multiple nodes installation'
            )


@attr.s(auto_attribs=True)
class SetupCtx:
    run_args: RunArgsSetupProvisionerGeneric
    profile_paths: Dict
    ssh_client: SaltSSHClient


class SetupCmdBase:

    @staticmethod
    def setup_location(
        run_args: RunArgsSetupProvisionerGeneric
    ) -> Optional[Path]:
        return (
            run_args.profile.parent if run_args.profile else
            config.profile_base_dir().parent
        )

    @staticmethod
    def setup_name(run_args: RunArgsSetupProvisionerGeneric) -> str:
        res = (
            run_args.profile.name if run_args.profile else run_args.name
        )
        if not res:
            res = '__'.join(
                [str(node) for node in run_args.nodes]
            ).replace(':', '_')
        return res
