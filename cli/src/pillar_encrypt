#!/usr/bin/python3
#
# Copyright (c) 2020 Seagate Technology LLC and/or its Affiliates
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# For any questions about this software or licensing,
# please email opensource@seagate.com or cortx-questions@seagate.com.
#

#!/usr/bin/python3

# Encrypts passwords in pillar in place
import argparse
import errno
import logging
import os
import salt.client
import sys
import yaml

from eos.utils.security.cipher import Cipher, CipherInvalidToken

logger = logging.getLogger(__name__)
handler = logging.FileHandler('/var/log/seagate/provisioner/pillar-encrypt.log', mode='w')
handler.setLevel(logging.INFO)
handler.setFormatter(logging.Formatter("[%(levelname)s - %(asctime)s]: %(message)s"))
logger.addHandler(handler)

class PillarEncrypt(object):


    def __init__(self):
        self.__options = {}

    def __load(self, sls_file):
        # No need to check file before open as we know, it exists.
        with open(sls_file, 'r') as fd:
            self.__options.update(yaml.safe_load(fd))


    def __save(self, sls_file):
        with open(sls_file, 'w') as fd:
            yaml.safe_dump(
                self.__options,
                stream=fd,
                default_flow_style=False,
                canonical=False,
                width=1,
                indent=4
            )
        self.__options.clear()


    def __encrypt_all_password_field(self, data, cipher_key):
        for key, val in data.items():
            if isinstance(val, dict):
                data[key] = self.__encrypt_all_password_field(val, cipher_key)
            else:
                if (("secret" in key) or ("password" in key)) and (val):
                    try:
                        (Cipher.decrypt(cipher_key, val.encode("utf-8"))).decode("utf-8")
                        data[key] = val
                        # Already encrypted, do nothing
                    except CipherInvalidToken:
                        data[key] = str(Cipher.encrypt(cipher_key, bytes(val,'utf8')),'utf-8')
        return data


    def __decrypt_all_password_field(self, data, cipher_key):
        for key, val in data.items():
            if isinstance(val, dict):
                data[key] = self.__decrypt_all_password_field(val, cipher_key)
            else:
                if (("secret" in key) or ("password" in key)) and (val):
                    try:
                        data[key] = (Cipher.decrypt(cipher_key, val.encode("utf-8"))).decode("utf-8")
                    except CipherInvalidToken:
                        # Already decrypted, nothing to do
                        data[key] = val
                    
        return data


    def execute(self, pillar_dir):
        if not os.path.exists(pillar_dir):
            raise FileNotFoundError(
                errno.ENOENT,
                os.strerror(errno.ENOENT),
                pillar_dir
            )
        
        arg_parser = argparse.ArgumentParser(
            description='Encrypt passwords in Salt Pillar data.'
        )

        arg_parser.add_argument(
            '-d', '--decrypt',
            help='Decrypt passwords in provisioning data.',
            action="store_true"
        )
        
        flag = arg_parser.parse_args()

        cluster_id = salt.client.Caller().function('grains.get', 'cluster_id')
        
        with os.scandir(pillar_dir) as dir_elements:
            for file_element in dir_elements:
                if file_element.is_file() and file_element.name.endswith('.sls'):
                    # print(f"SLS file: {file_element.name}")
                    sls_file = os.path.join(
                        pillar_dir,
                        f"{file_element.name}"
                    )

                    self.__load(sls_file)
        
                    cipher_key = Cipher.generate_key(
                                    cluster_id,
                                    list(self.__options.keys())[0]
                                )

                    if flag.decrypt:
                        logger.info("Decryption started for {}".format(file_element.name))
                        self.__options.update(
                            self.__decrypt_all_password_field(
                                self.__options,
                                cipher_key
                            )
                        )
                    else:
                        logger.info("Encryption started for {}".format(file_element.name))
                        self.__options.update(
                            self.__encrypt_all_password_field(
                                self.__options,
                                cipher_key
                            )
                        )

                    self.__save(sls_file)

        logger.info("DONE")


if __name__ == "__main__":
    try:
        _root_path = os.path.join('/', 'opt', 'seagate', 'cortx', 'provisioner')
        pillar_paths = [(os.path.join(_root_path, 'pillar', 'components')),
            os.path.join(_root_path, 'pillar', 'user', 'groups', 'all'),
            os.path.join('/', 'var', 'lib', 'seagate', 'cortx', 'provisioner', 'shared', 'srv', 'pillar', 'groups', 'all')]
        for pillar_path in pillar_paths:
            try:
                # Ensure pillars in all paths are encrypted
                PillarEncrypt().execute(pillar_path)
            except FileNotFoundError as err:
                logger.exception("Path doesn't exist: {0}".format(err))

    except KeyboardInterrupt:
        print("\n\nWARNING: User aborted command. Partial data save/corruption might occur. It is advised to re-run the command.")
        sys.exit(1)
