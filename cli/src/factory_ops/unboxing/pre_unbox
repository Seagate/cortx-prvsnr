#!/bin/bash

# This is the pre-unbox script for Seagate Cortx Lyve Drive Rack
# This script is expected to be run after the Cortx hardware is
# set up as per the instruction mentioned in Cortx LDR User Guide.
# The script may prompt user for input, if required.
# Please keep following data handy before running the script:
# 1. Storage Controller IP addresses (2 nos - one for each controller) 
# 2. Hostnames for Sever A and hostnames for Server B, this will be
#     required if DNS/DHCP is not configured in the lab for auto assignment
#     of hostname using mac addresses.

# Following steps are performed as part of the script:
# 1. Run cleanup 
#     1.1 Check, if subscription-manager is enabled
#     1.2 Disable and cleanup the subscription
#     1.3 Remove all Seagate internal repos from /etc/yum.repos.d
# 2. Check if the volumes are being listed on both the nodes - lsblk
#     2.1 Run 'lsblk -S | grep sas | wc -l' command on both the servers
#     2.2 The output should be equal to $nvols (64)
#     2.3 If the output is not equal to $nvols (64) then error out with diagnostic steps.
# 3. Get the controller IPs from user as an input
#     3.1 Prompt user to provide IP address for controller A
#     3.2 Prompt user to provide IP address for controller B
#     3.3 Update the IP addresses in storage pillar
#         3.1 If the ips provided by user matches the current values in pillar, do nothing.
# 4. Check, if the hostname contains 'seagate.com', if yes, take input for new hostname
#     4.1 Get the current hostname
#     4.2 Check, if the hostname has .seagate.com sub-string
#     4.3 If yes, get the new hostnames from user, else do nothing.
#     4.4 Print the new names and ask for confirmation
#         4.4.1 If user doesn't confirm, then prompt user again to provide the new hostnames.
#         4.4.2 Proceed if user confirms the hostname
#     4.5 Set the hostnames on the servers
#         4.5.1 Restart hostname service
#         4.5.2 Check the hostname again to ensure it's set correctly
#         4.5.3 If hostname is not set to new hostname, then try one more time with `chattr -i /etc/hostname`
#         4.5.4 Exit, providing the diagnostic steps
# 5. Update hostnames in local dns (/etc/hosts)
#     5.1 Grab the IP address for MGMT interface from 'ip a' output
#     5.2 Check, if hostnames are getting resolved to mgmt ip addresses
#     5.3 Add the new ip & hostnames to /etc/hosts
#         5.3.1 Is mgmt_ip_A already added in /etc/hosts on node A?
#             5.3.1.1 Yes: mgmt_ip_A is added in /etc/hosts
#                 Is the entry against hostname_A?
#                     Yes: We are good, do nothing. 
#                     No: Update the hostname against the mgmt_ip_A
#             5.3.1.2 No: add the new entry in /etc/hosts for mgmt_ip_A
#         5.3.2 Repeat 5.3.1 and sub-set for mgmt_ip_B on node A.
#         5.3.3 Repeat 5.1 through to 5.3.2 for node B
# 6. Update hostnames in ssh config files
#     1. Update new hostnames in /root/.ssh/config file on Server A
#     2. Copy using scp file /root/.ssh/config from Server A to Server B
#     3. Check ssh connectivity, from server A to server B using alias/minion id (srvnode-2)
#     4. Check ssh connectivity, from server B to server A using alias/minion id (srvnode-1)
#     5. Check, if the ssh works without password from Server A to Server B using new hostname
#     6. Check, if the ssh works without password from Server B to Server A using new hostname
# 7. Update minion files on both the nodes to point salt-master to server A hostname
#     1. Update primary node hostname in file /etc/salt/minion with hostname of Server A 
#     2. Update primary node hostname in file /etc/salt/minion with hostname of Server B 
#     3. Restart salt-minion service on Server A
#     4. Restart salt-minion service on Server B
#     5. Restart salt-master service on Server A
#     6. Check if 'salt '*' test.ping' works
# 8. Run the unboxing script

set -euE
export LOG_FILE="${LOG_FILE:-/var/log/seagate/provisioner/pre_unbox.log}"
mkdir -p $(dirname "${LOG_FILE}")

PRVSNR_ROOT="/opt/seagate/cortx/provisioner"

# Global variables, which can be set externally using environment variables
default_hostname_nodeA="${default_hostname_nodeA:-"cortx-node-a"}"
default_hostname_nodeB="${default_hostname_nodeB:-"cortx-node-b"}"
export pvt_ip_a="${pvt_ip_a:-"192.168.0.1"}"
export pvt_ip_b="${pvt_ip_b:-"192.168.0.2"}"
#TODO: The no of volumes for Beta are 32.
nvols="${nvols:-64}" # The default value needs to be changed to 64 for cross connect

if [[ -d "/var/lib/seagate/cortx/provisioner/shared/srv/pillar/groups/all" ]]; then
    export pillar_root="/var/lib/seagate/cortx/provisioner/shared/srv/pillar/groups/all"
elif [[ -d "/srv/glusterfs/volume_prvsnr_data/srv/pillar/groups/all" ]]; then
    export pillar_root="/srv/glusterfs/volume_prvsnr_data/srv/pillar/groups/all"
else
    echo "ERROR: Cluster data is not updated correctly" >> ${LOG_FILE}
    exit 1
fi

#force update the hostname
force_update_hname="${force_update_hname:-"false"}"
amend_fix_for_ipmi="${amend_fix_for_ipmi:-"true"}"

# Global variables, don't change these values.

export ssh_cmd="ssh -q -o ConnectTimeout=5 -o PreferredAuthentications=publickey -o StrictHostKeyChecking=no -i /root/.ssh/id_rsa_prvsnr"
export scp_cmd="scp -q -o ConnectTimeout=5 -o PreferredAuthentications=publickey -o StrictHostKeyChecking=no -i /root/.ssh/id_rsa_prvsnr"

pvt_ips=("${pvt_ip_a}" "${pvt_ip_b}")
minion_ids=("srvnode-1" "srvnode-2")
server_names=("Server A" "Server B") #Required for logging messages

# Variables for stpring inputs from user
ctrl_ip_a=
ctrl_ip_b=

# These variables will be updated in /etc/hosts, ssh config and salt config
hostname_A=
hostname_B=
mgmt_ip_A=
mgmt_ip_B=
ssh_A_to_B=
ssh_B_to_A=

function err_handler_pu {
    echo "\
**************************FAILED!!********************************
For detailed error logs, please see: $LOG_FILE
******************************************************************" | tee -a ${LOG_FILE}
    exit 1
}

function intrpt_handler_pu {
    echo -e "\n\n\
------------------------------------------------------------------
Received Ctrl-c signal [SIGINT], exiting Gracefully.
For detailed logs, please see: $LOG_FILE
------------------------------------------------------------------" | tee -a ${LOG_FILE}

    exit 1
}

trap err_handler_pu ERR
trap intrpt_handler_pu SIGTERM SIGINT

sub_manager_check()
{
    _pvt_ip="${1:-$pvt_ip_a}"
    _server="${2:-"Server A"}"

    $ssh_cmd $_pvt_ip "grep -qE \"Red Hat\" /etc/*-release" || {
        echo "$_server is not a RedHat system" | tee -a ${LOG_FILE}
        subscription_enabled=false
        return
    }

    echo "Checking if Red Hat subscription is enabled on ${_server}" | tee -a ${LOG_FILE}
    subc_list=`$ssh_cmd $_pvt_ip "subscription-manager list" | grep Status: | awk '{ print $2 }'`
    subc_status=`$ssh_cmd $_pvt_ip "subscription-manager status" | grep "Overall Status:" | awk '{ print $3 }'`
    if echo "$subc_list" | grep -q "Subscribed"; then
        if [[  "$subc_status" == "Current" ]]; then
            echo "RedHat subscription is enabled on ${_server}." | tee -a ${LOG_FILE}
            subscription_enabled=true
        else
            echo "RedHat subscription is disabled on ${_server}." | tee -a ${LOG_FILE}
            subscription_enabled=false
        fi
    fi
}

sub_manager_cleanup()
{
    _pvt_ip="${1:-$pvt_ip_a}"
    _server=${2:-"Server A"}

    $ssh_cmd $_pvt_ip "grep -qE \"Red Hat\" /etc/*-release" || {
        echo "${_server} is not a RedHat system" | tee -a ${LOG_FILE}
        return
    }
    echo "Removing the Red Hat subscription from ${_server}" | tee -a ${LOG_FILE}

    echo "DEBUG: Running the subscription-manager list on ${_server}" >> ${LOG_FILE}
    $ssh_cmd $_pvt_ip "subscription-manager list || true"  | tee -a ${LOG_FILE}

    echo "DEBUG: Running the subscription-manager auto-attach on ${_server}" >> ${LOG_FILE}
    $ssh_cmd $_pvt_ip "subscription-manager auto-attach --disable || true"  | tee -a ${LOG_FILE}

    echo "DEBUG: Running subscription-manager remove --all on ${_server}" >> ${LOG_FILE}
    $ssh_cmd $_pvt_ip "subscription-manager remove --all || true" | tee -a ${LOG_FILE}

    echo "DEBUG: Running subscription-manager unregister on ${_server}" >> ${LOG_FILE}
    $ssh_cmd $_pvt_ip "subscription-manager unregister || true" | tee -a ${LOG_FILE}

    echo "DEBUG: Running subscription-manager clean on ${_server}" >> ${LOG_FILE}
    $ssh_cmd $_pvt_ip "subscription-manager clean || true" | tee -a ${LOG_FILE}

    echo "DEBUG: Running subscription-manager config --rhsm.manage_repos=0 on ${_server}" >> ${LOG_FILE}
    $ssh_cmd $_pvt_ip "subscription-manager config --rhsm.manage_repos=0" | tee -a ${LOG_FILE}
    echo "Done." | tee -a ${LOG_FILE}
}

seagate_refs_cleanup()
{
    # 1. Check if subscription manager is enabled
    # 2. Disable and cleanup the subscription 
    # 3. Remove all Seagate internal repos from /etc/yum.repos.d

    for i in "${!pvt_ips[@]}"; do
        echo "Running for node:${pvt_ips[$i]}" >> ${LOG_FILE}
        if $ssh_cmd ${pvt_ips[$i]} 'grep -q "Red Hat" /etc/*-release'; then
            echo "RedHat system, checking if Redhat subscription is enabled." >> ${LOG_FILE}
            subscription_enabled=false
            sub_manager_check "${pvt_ips[$i]}" "${server_names[$i]}"
            if [[ "$subscription_enabled" == true ]]; then
                echo "Disabling the RedHat Subscription" >> ${LOG_FILE}
                sub_manager_cleanup "${pvt_ips[$i]}" "${server_names[$i]}"
            else
                echo "RedHat Subscription is already disabled" >> ${LOG_FILE}
            fi
        else
            echo "Non RedHat system, disabling the subscription is not needed" >> ${LOG_FILE}
        fi

        _n_repos=$($ssh_cmd ${pvt_ips[$i]} "ls -1 /etc/yum.repos.d/*.repo 2>/dev/null | wc -l")
        echo "_n_repos=$_n_repos" >> ${LOG_FILE}
        if [[ $_n_repos -ne 0 ]]; then
            echo "Checking if there is salt or seagate references in repos" >> ${LOG_FILE}
            if $ssh_cmd ${pvt_ips[$i]} 'grep -liEq "cortx|seagate|salt" /etc/yum.repos.d/*.repo'; then
                $ssh_cmd ${pvt_ips[$i]} 'for file in `grep -liE "cortx|seagate|salt" /etc/yum.repos.d/*.repo`;\
                    do if ! grep -q "file://" $file; then\
                        echo "Removing repo file: $file";
                        mkdir -p /opt/seagate/cortx_configs/provisioner_generated/repos_backup_unboxing
                        yes | mv -f "$file" /opt/seagate/cortx_configs/provisioner_generated/repos_backup_unboxing/; 
                        fi;
                    done'
            fi
            $ssh_cmd ${pvt_ips[$i]} 'for file in `grep -lE "baseurl=None|baseurl=/3rd_party|baseurl=/cortx_iso" /etc/yum.repos.d/*.repo`;\
                    do\
                    echo "Removing repo: $file";\
                    yes | mv -f "$file" /opt/seagate/cortx_configs/provisioner_generated/repos_backup_unboxing;\
                    done'  >> ${LOG_FILE}
            echo "Cleaning yum cache on ${server_names[$i]}" | tee -a ${LOG_FILE}
            $ssh_cmd ${pvt_ips[$i]} "yum clean all || true"  >> ${LOG_FILE}
        else
            echo "No repos found with seagate references, ignoring" >> ${LOG_FILE}
        fi
    done
}

luns_availability_check()
{
    # 1. Run 'lsblk -S | grep sas | wc -l' command on both the servers
    # 2. The output should be equal to $nvols
    # 3. If the output is not equal to $nvols then error out with diagnostic steps.

    echo "Checking if the LUNs from storage enclosure are available" | tee -a ${LOG_FILE}
    for i in "${!pvt_ips[@]}"; do
        echo "DEBUG: Listing luns on server ${server_names[$i]}" >> ${LOG_FILE}
        $ssh_cmd ${pvt_ips[$i]} "lsblk -S| grep sas" >> ${LOG_FILE}
        _nluns=$($ssh_cmd ${pvt_ips[$i]} "lsblk -S" | grep sas | wc -l)
        echo "DEBUG: Number of luns on server ${server_names[$i]}: $_nluns" >> ${LOG_FILE}
        if [[ $_nluns -eq 0 || $_nluns -ne $nvols ]]; then
            echo "---------- FAILED!!! -------------" | tee -a ${LOG_FILE}
            echo "Error: The number of LUNs from storage enclosure ($_nluns) are not correct on ${server_names[$i]}." | tee -a ${LOG_FILE}
            echo -e "Try following steps before running the command again:\n\
1. Please make sure the storage enclosure is connected to servers as shown in the user guide.
2. If the connections to the storage enclosure are correct, then try rebooting the ${server_names[$i]} once.
3. After the reboot of server(s) run 'lsblk -S | grep sas | wc -l', to check the number of LUNs available.
4. Once the output of 'lsblk -S | grep sas | wc -l' is $nvols on both the servers, re-run this command '$0'" | tee -a ${LOG_FILE}
            exit 1
        fi
        echo "The number of LUNs ($_nluns) are correct on ${server_names[$i]}"  | tee -a ${LOG_FILE}
    done
}

ctrl_ip_addr_get_set()
{
    # 1.  Prompt user to provide IP address for controller A
    # 2.  Prompt user to provide IP address for controller B
    # 3.  Update the IP addresses in storage pillar
    # 3.1 If the ips provided by user matches the current values in pillar, do nothing.

    echo "Please provide the IP addresses for storage enclosure (should be already configured)" | tee -a ${LOG_FILE}
    while true; do
        echo -n "Enter IP address configured for Controller A: " | tee -a ${LOG_FILE}
        read ctrl_ip_a
        echo -e "\nDEBUG: Input received for Controller A IP: ${ctrl_ip_a}" >> ${LOG_FILE}
        if [[ -z $ctrl_ip_a ]]; then
            echo "Please provide the valid input." | tee -a ${LOG_FILE}
        else
            echo "DEBUG: IP address received for Controller A: ${ctrl_ip_a}" >> ${LOG_FILE}
            break
        fi
    done

    #TODO: remove duplicate code for controller B, add it in for loop.
    while true; do
        echo -n "Enter IP address configured for Controller B: "  | tee -a ${LOG_FILE}
        read ctrl_ip_b
        echo -e "\nDEBUG: input received for Controller B IP: ${ctrl_ip_b}" >> ${LOG_FILE}
        if [[ -z $ctrl_ip_b ]]; then
            echo "Please provide valid input." | tee -a ${LOG_FILE}
        else
            echo "DEBUG: IP address received for Controller B: ${ctrl_ip_b}" >> ${LOG_FILE}
            break
        fi
    done

    #Update the storage pillar with new controller IP.
    _storage_encl_sls_path="${pillar_root}/uu_storage.sls"
    if [[ ! -f "${_storage_encl_sls_path}" ]]; then
        echo "ERROR: \"${_storage_encl_sls_path}\" no such file or directory"
        exit 1
    fi
    echo "Updating IP addresses of storage enclosure in Salt pillar" |tee -a ${LOG_FILE}

    echo "Updating storage enclosure pillar with new controller A IP address" | tee -a ${LOG_FILE}
    _current_ip=$(grep -A1 primary ${_storage_encl_sls_path} | tail -1 | awk '{ print $2 }')
    echo "DEBUG:_current_ip=${_current_ip}" >> ${LOG_FILE}
    cat ${_storage_encl_sls_path} | sed -e "s/${_current_ip}/${ctrl_ip_a}/" > /tmp/ctrla-sed.tmp
    diff_lines=$(diff ${_storage_encl_sls_path} /tmp/ctrla-sed.tmp | grep "<" | wc -l)
    #Check and ensure there is only one line change in the diff
    if [[ $diff_lines -eq 1 ]]; then
        # Only one line is changed, as expected.
        # Take backup of the original file
        if [[ ! -f ${_storage_encl_sls_path}.orig ]]; then
            # always take backup of original file as .orig & don't overwrite it
            yes | cp -f ${_storage_encl_sls_path} ${_storage_encl_sls_path}.orig
        else
            # overwrite the .bak file if present
            yes | cp -f ${_storage_encl_sls_path} ${_storage_encl_sls_path}.bkp
        fi
        # Replace the actual file with the file generated by sed with new ip
        yes | cp -f /tmp/ctrla-sed.tmp ${_storage_encl_sls_path}

    elif [[ $diff_lines -eq 0 ]]; then
        # old ip and new ip are matching, prbably due to rerun of 
        # the command or updating the pillar manually, do nothing.
        echo "DEBUG: The IP address provided for controller A is already present in storage enclosure pillar, ignoring..." >> ${LOG_FILE}
    else
        # sed didn't work as expected (was supposed to change only one line)
        echo "ERROR: Could not update the storage enclosure pillar with new controller A IP address." | tee -a ${LOG_FILE}
        echo "ERROR: Please update it manually in ${_storage_encl_sls_path} and run the command again." | tee -a ${LOG_FILE}
        exit 1
    fi
    echo "Done" | tee -a ${LOG_FILE}

    echo "Updating storage enclosure pillar with new controller B IP address" | tee -a ${LOG_FILE}
    _current_ip=$(grep -A1 secondary ${_storage_encl_sls_path} | tail -1 | awk '{ print $2 }')
    cat ${_storage_encl_sls_path} | sed -e "s/${_current_ip}/${ctrl_ip_b}/" > /tmp/ctrlb-sed.tmp
    diff_lines=$(diff ${_storage_encl_sls_path} /tmp/ctrlb-sed.tmp | grep "<" | wc -l)
    #Check and ensure there is only one line change in the diff
    if [[ $diff_lines -eq 1 ]]; then
        # Only one line is changed, as expected.
        # Take backup of the original file
        if [[ ! -f ${_storage_encl_sls_path}.orig ]]; then
            # always take backup of original file as .orig & don't overwrite it
            yes | cp -f ${_storage_encl_sls_path} ${_storage_encl_sls_path}.orig
        else
            # overwrite the .bak file if present
            yes | cp -f ${_storage_encl_sls_path} ${_storage_encl_sls_path}.bkp
        fi
        # Update the file generated by sed with new ip
        yes | cp -f /tmp/ctrlb-sed.tmp ${_storage_encl_sls_path}
    elif [[ $diff_lines -eq 0 ]]; then
        # old ip and new ip match, prbably due to rerun of 
        # the command or updating the pillar manually
        echo "DEBUG: The IP address provided for controller B is already present in storage enclosure pillar, ignoring" >> ${LOG_FILE}
    else
        # sed didn't work as expected (was supposed to change only one line)
        echo "ERROR: Could not update the storage enclosure pillar with new controller B IP address" | tee -a ${LOG_FILE}
        echo "ERROR: Please update it manually in ${_storage_encl_sls_path} and run the command again" | tee -a ${LOG_FILE}
        exit 1
    fi
    echo "Done" | tee -a ${LOG_FILE}
}

new_hostname_set()
{
    # Set the hostname on both the servers
    # Set the hostname only if user has provided the new hostname
    # After hostname is set, sleep for 30s
    # Check the hostname again, and ensure it is the new hostname

    _set_hostname_flags=("$@")
    echo "DEBUG: _set_hostname_flags=${_set_hostname_flags[@]}" >> ${LOG_FILE}
    for i in "${!pvt_ips[@]}"; do

        echo "Setting the new hostname provided by user" | tee -a ${LOG_FILE}
        if [[ $i -eq 0 && ! -z $hostname_A && "${_set_hostname_flags[$i]}" == true ]]; then
            echo "Setting the hostname ("${hostname_A}") for server A" | tee -a ${LOG_FILE}
            _new_hostname=$hostname_A
        elif [[ $i -eq 1 && ! -z $hostname_B && "${_set_hostname_flags[$i]}" == true ]]; then
            echo "Setting the hostname(${hostname_B}) for server B" | tee -a ${LOG_FILE}
            _new_hostname=$hostname_B
        else
            echo "DEBUG: i=$i, hostname_A=${hostname_A}, hostname_B=${hostname_B}, ${_set_hostname_flags[$i]}" >> ${LOG_FILE}
            echo "DEBUG: no hostname provided by user for ${server_names[$i]}, skipping" >> ${LOG_FILE}
            continue
        fi
    
        $ssh_cmd ${pvt_ips[$i]} "hostnamectl set-hostname --static --transient --pretty ${_new_hostname}" 2>&1 | tee -a ${LOG_FILE}
        echo "Restarting the hostnamed service" | tee -a ${LOG_FILE}
        systemctl restart systemd-hostnamed 2>&1 | tee -a ${LOG_FILE}
        echo "Waiting for the new hostname to get updated in system for ${server_names[$i]}" | tee -a ${LOG_FILE}
        sleep 30
        # Get the current hostname again from the system
        _hostname=$($ssh_cmd ${pvt_ips[$i]} "hostnamectl status" | grep "Static hostname" | awk '{ print $3 }')
        # Check if the current hostname is same as new hostname provided by user
    
        if [[ "$_hostname" == "${_new_hostname}" ]]; then
            echo "New hostname(${_new_hostname}) is set successfully for ${server_names[$i]}" | tee -a ${LOG_FILE}
        else
            # DNS is not allowing to change the hostname
            # Change the attribute of hostname file
            echo "Warning: The hostname provided (${_new_hostname}) could not be set on ${server_names[$i]}" | tee -a ${LOG_FILE}
            echo "Retrying.." | tee -a ${LOG_FILE}
            $ssh_cmd ${pvt_ips[$i]} "chattr -i /etc/hostname" 2>&1 | tee -a ${LOG_FILE}
            $ssh_cmd ${pvt_ips[$i]} "hostnamectl set-hostname --static --transient --pretty "${_new_hostname}"" 2>&1 | tee -a ${LOG_FILE}
            echo "Restarting the hostnamed service" | tee -a ${LOG_FILE}
            systemctl restart systemd-hostnamed 2>&1 | tee -a ${LOG_FILE}
            echo "Waiting for the new hostname to get updated in system for ${server_names[$i]}" | tee -a ${LOG_FILE}
            sleep 30
            # Check again if the hostname provided by user got updated in the system
            _hostname=$($ssh_cmd ${pvt_ips[$i]} "hostnamectl status" | grep "Static hostname" | awk '{ print $3 }')
    
            if [[ "$_hostname" == "${_new_hostname}" ]]; then
                echo "New hostname(${_new_hostname}) is set successfully for ${server_names[$i]}" | tee -a ${LOG_FILE}
            else
                #TODO: Give one more try with 
                # 1. nmcli general hostname ${_new_hostname}
                # 2. sysctl kernel.hostname=${_new_hostname}
                echo "Error: The hostname provided (${_new_hostname}) could not be set on ${server_names[$i]}
Please do the following steps:
1. Check whether the dns/dhclient settings in the lab/data_centre environment are causing problems to update the hostname.
2. If yes, please set the hostnames through DNS using mac addresses mentioned in Quick install information sheet provided by Seagate.
3. If changing DNS is not possible or it's not working, try to change the hostname manually using following commands:
   1. hostnamectl set-hostname --static --transient --pretty ${_new_hostname}
   2. nmcli general hostname ${_new_hostname}
   3. sysctl kernel.hostname=${_new_hostname}
   NOTE: Run these commands one at a time, if command no. 1 doesn't work then only try command no. 2 and so on.
         Also wait for couple of minutes after the command is run and check 'hostnamectl status' again to ensure the hostname indeed has changed.
4. If the above commands also don't work, it's mostly the network settings in the lab that is causing the problem.
   To bypass the network settings:
   1. Remove the network cables from the servers to switch
   2. Set the the hostnames again using commands mentioned in step 3 above
5. If the hostnames are updated successfully re-run the pre-unbox command again to proceed

The pre-unbox command did not complete, exiting." | tee -a ${$LOG_FILE}
                exit 1
            fi
        fi
    
        if [[ $i -eq 0 ]]; then 
            hostname_A=${_hostname}
        else
            hostname_B=${_hostname}
        fi 
    done
}

new_hostname_get()
{
    _tnode="${1:-\"Server A\"}"
    # Prompt user for the new hostname (suggest sample hostname as an example)

    if [[ "$_tnode" == "Server A" ]]; then
        echo -n "Enter new hostname for server A (press enter to keep default [${default_hostname_nodeA}]): " | tee -a ${LOG_FILE}
        read hostname_A
        echo -e "\nDEBUG: input received for Server A hostname: ${default_hostname_nodeA}" >> ${LOG_FILE}
        hostname_A=${hostname_A:-$default_hostname_nodeA}
    else
        echo -n "Enter new hostname for server B (press enter to keep default [${default_hostname_nodeB}]): " | tee -a ${LOG_FILE}
        read hostname_B
        echo -e "\nDEBUG: input received for Server B hostname: ${default_hostname_nodeB}" >> ${LOG_FILE}
        hostname_B=${hostname_B:-$default_hostname_nodeB}
    fi
}

hostname_validate_get_set()
{
    # 1 Get the current hostname
    # 2 Check if the hostname has .seagate.com
    # 3 If yes, get the new hostnames from user, else do nothing.
    # 4 Print the new names and ask for confirmation
    #    4.1 If user don't confirm, then exit and ask user to rerun the command.
    #    4.2 Proceed if user confirms the hostname
    # 5 Set the hostnames on the servers
    #    5.1 restart hostname service
    #    5.2 check the hostname again to ensure it's set correctly
    #    5.3 if hostname is not set to new hostname then try one more time 
    #    5.4 exit after providing the diagnostic steps

    _seagate_hname=false

    #for to check if hostname is to be set, default false for both nodes
    _set_hostnames=("false" "false")
 
    echo "Validating the current hostnames on both servers" | tee -a ${LOG_FILE}
 
    for i in "${!pvt_ips[@]}"; do
        echo "Running hostname check on ${server_names[$i]}" >> ${LOG_FILE}
        _hname=$($ssh_cmd ${pvt_ips[$i]} "hostnamectl status" | grep "Static hostname" | awk '{ print $3 }')
        echo $_hname | grep -q "seagate.com" && _seagate_hname=true || _seagate_hname=false
        if [[ "${_seagate_hname}" == true ]]; then
            echo "The hostname of ${server_names[$i]} contains the seagate domain name" >> ${LOG_FILE}
            echo "The hostname needs to be changed for ${server_names[$i]}" | tee -a ${LOG_FILE}
            _set_hostnames[$i]=true
        else
            echo "The current hostname ($_hname) for ${server_names[$i]} looks good" | tee -a ${LOG_FILE}
            if [[ "${server_names[$i]}" == "Server A" ]]; then
                hostname_A=${_hname}
                echo "The hostname of server A: ${hostname_A}" | tee -a ${LOG_FILE}
            else
                hostname_B=${_hname}
                echo "The hostname of server B: ${hostname_B}" | tee -a ${LOG_FILE}
            fi
        fi
    done

    while true; do
        for i in "${!_set_hostnames[@]}"; do
            # Get and print the new hostname provided by user
            # and confirm before proceeding ahead
            if [[ "${_set_hostnames[$i]}" == true ]]; then
                # Hostname needs to be set
                echo "Requesting user to provide hostname for ${server_names[$i]}" >> ${LOG_FILE}
                new_hostname_get "${server_names[$i]}"
            fi
        done
        for i in "${!_set_hostnames[@]}"; do
            if [[ "${_set_hostnames[$i]}" == true ]]; then
                if [[ "${server_names[$i]}" == "Server A" ]]; then
                    echo "New hostnames provided by user for Server A: ${hostname_A}" | tee -a ${LOG_FILE}
                else
                    echo "New hostnames provided by user for Server B: ${hostname_B}" | tee -a ${LOG_FILE}
                fi
            else
                if [[ "${server_names[$i]}" == "Server A" ]]; then
                    echo "Current hostname on Server A is            : ${hostname_A}" | tee -a ${LOG_FILE}
                else
                    echo "Current hostname on Server B is            : ${hostname_B}" | tee -a ${LOG_FILE}
                fi
            fi
        done
        _proceed=true
        while true; do
            echo -n "Do you want to proceed with these host names? (y/n): " | tee -a ${LOG_FILE}
            read _ans
            echo -e "\nDEBUG: input received $_ans" >> ${LOG_FILE}
            case $_ans in
                [Yy]* ) _proceed=true; break;;
                [Nn]* ) _proceed=false; break;;
                * ) echo "Please answer y or n.";;
            esac
        done
        if [[ "$_proceed" == true ]]; then
            # User wants to proceed with the hostnames
            echo "Proceeding to set the provided hostnames..." | tee -a ${LOG_FILE}
            break
        else
            # User don't wants to proceed with the hostnames
            # Prompt the user again
            while true; do
                echo -n "Which server do you want to update the hostname of? (A/B/both): " | tee -a ${LOG_FILE}
                read _ans
                echo -e "\nDEBUG: _ans:$_ans, _set_hostnames[$i]=${_set_hostnames[$i]}" >> ${LOG_FILE}
                case $_ans in
                    [Aa]) _set_hostnames=("true" "false");
                            for i in "${!_set_hostnames[@]}"; do
                                echo "DEBUG: case A: i=$i, _set_hostnames[$i]=${_set_hostnames[$i]}" >> ${LOG_FILE}
                            done
                            break;;
                    [Bb]) _set_hostnames=("false" "true");
                            for i in "${!_set_hostnames[@]}"; do
                                echo "DEBUG: case B: i=$i, _set_hostnames[$i]=${_set_hostnames[$i]}" >> ${LOG_FILE}
                            done
                            break;;
                    both) _set_hostnames=("true" "true");
                            for i in "${!_set_hostnames[@]}"; do
                                echo "DEBUG: case both: i=$i, _set_hostnames[$i]=${_set_hostnames[$i]}" >> ${LOG_FILE}
                            done
                            break;;
                    * ) echo "Please answer A/B or both.";;
                esac
            done
            echo "Okay, please provide the hostnames again" | tee -a ${LOG_FILE}
            continue
        fi
    done

    new_hostname_set "${_set_hostnames[@]}"
}

ping_status_A_to_B=false
ping_status_B_to_A=false

hosts_resolution_check()
{
    # grab & save the IP addresses for MGMT interface from 'ip a' output for both nodes
    # Save & print the hostnames for both nodes
    # Check if 'ping <Server B hostname>' works from Server A
    # Check if 'ssh <pvt ip B> "ping <Server B hostname>"' works
    # Add the new ip & hostnames to /etc/hosts

    # Get management interface name from pillar
    _cluster_sls_path="${pillar_root}/uu_cluster.sls"
    if [[ ! -f ${_cluster_sls_path} ]]; then
        echo "ERROR: \"${_cluster_sls_path}\" no such file or directory"
        exit 1
    fi
    local mgmt_if=$(grep -m1 -A3 -P "mgmt:" ${_cluster_sls_path}|grep -A1 "interfaces:"|tail -1|cut -d'-' -f2|tr -d "[:space:]")

    if [[ -z "$mgmt_if" ]]; then
        if ip -o addr | grep -q eno1; then
            mgmt_if="eno1"
        else
            echo "ERROR: Could not get the management interface" | tee -a ${LOG_FILE}
            exit 1
        fi
    fi

    echo "*****************************************************" | tee -a ${LOG_FILE}
    # Get management interface ip address for node1
    mgmt_ip_A=$((ip addr show dev ${mgmt_if}|grep inet|grep -v inet6|grep -Po "\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}" || echo "ERROR: IP address missing for ${mgmt_if} on Server A" || (tee -a ${LOG_FILE}; exit 1))|head -1)
    echo "Management IP on Server A    : ${mgmt_ip_A}" | tee -a ${LOG_FILE}

    # Get management ip address for node2
    mgmt_ip_B=$(($ssh_cmd ${pvt_ip_b} "ip addr show dev ${mgmt_if}|grep inet|grep -v inet6|grep -Po \"\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}\"" || (echo "ERROR: IP address missing for ${mgmt_if} on srvnode-2" | tee -a ${LOG_FILE}; echo 1))|head -1)
    echo "Management IP on Server B    : ${mgmt_ip_B}" | tee -a ${LOG_FILE}

    # Get current hostnames of the servers
    for i in "${!pvt_ips[@]}"; do
        echo "DEBUG: Getting current hostname on ${server_names[$i]}" >> ${LOG_FILE}
        _hname=$($ssh_cmd ${pvt_ips[$i]} "hostnamectl status" | grep "Static hostname" | awk '{ print $3 }')
        if [[ $i -eq 0 ]]; then hostname_A=${_hname}; else hostname_B=${_hname}; fi
        echo "Current hostname on ${server_names[$i]}: ${_hname}" | tee -a ${LOG_FILE}
    done
    echo "*****************************************************" | tee -a ${LOG_FILE}

    # Check if entries in /etc/hosts needs to be added.
    # The entry needs to be added only if the hostnames are NOT getting resolved from each other

    echo "Checking Servers connectivity from each other using the hostnames" >> ${LOG_FILE}
    echo "DEBUG: Checking if server B (${hostname_B}) is reachable from server A (${hostname_A}) using hostname" >> ${LOG_FILE}
    if ping -c1 -W2  $hostname_B > /dev/null; then
        # Ping is successfull, no need to add entry in /etc/hosts
        echo "Server A [${hostname_A}] --> Server B [${hostname_B}]: Reachable " | tee -a ${LOG_FILE}
        ping_status_A_to_B=true
    else
        # Ping failed, need to add entry in /etc/hosts
        echo "WARNING: Server A [${hostname_A}] --> Server B [${hostname_B}]: Not Reachable " | tee -a ${LOG_FILE}
        ping_status_A_to_B=false
    fi

    echo "DEBUG: Checking if server A (${hostname_A}) is reachable from Server B (${hostname_B}) using hostname" >> ${LOG_FILE}
    if $ssh_cmd ${pvt_ip_b} "ping -c1 -W2  ${hostname_A}" > /dev/null; then
        # Ping is successfull, no need to add entry in /etc/hosts
        echo "Server B [${hostname_B}] --> Server A [${hostname_A}]: Reachable " | tee -a ${LOG_FILE}
        ping_status_B_to_A=true
    else
        # Ping failed, need to add entry in /etc/hosts
        echo "WARNING: Server B [${hostname_B}] --> Server A [${hostname_A}]: Not Reachable " | tee -a ${LOG_FILE}
        ping_status_B_to_A=false
    fi

    if [[ "$ping_status_A_to_B" == true && "$ping_status_B_to_A" == true ]]; then
        # No need to add dns entry
        echo "DEBUG: Hostnames are reachable from each other, no need add hosts entry in /etc/hosts" >> ${LOG_FILE}
        return
    fi
}

dns_update_hostnames()
{
    # Steps to add entries in /etc/hosts
    # 1. Is mgmt_ip_A already added in /etc/hosts on node A?
    #     1.1 Yes: mgmt_ip_A is added in /etc/hosts
    #            Is the entry against hostname_A? 
    #              Yes: We are good, do nothing. 
    #              NO: Update the hostname against the mgmt_ip_A
    #     1.2 No: add the new entry in /etc/hosts for mgmt_ip_A
    # 2. Repeat for mgmt_ip_B on node A.
    # 3. Repeat 1 and 2 for node B
    # TODO: Remove duplicate code.

    echo "DEBUG: hostname_A: ${hostname_A}, hostname_B: ${hostname_B}" >> ${LOG_FILE}
    echo "DEBUG: mgmt_ip_A: ${mgmt_ip_A}, mgmt_ip_B: ${mgmt_ip_B}" >> ${LOG_FILE}
    # node A
    echo "Checking /etc/hosts on both the servers" | tee -a ${LOG_FILE}
    echo "DEBUG: Checking /etc/hosts on Server A" >> ${LOG_FILE}
    echo "DEBUG: Checking host entries in /etc/hosts on server A for management IP of server A (${mgmt_ip_A})" >> ${LOG_FILE}
    if [[ ! -f /etc/hosts ]]; then
        echo "ERROR: /etc/hosts file not present. Please create the file manually and rerun the command." | tee -a ${LOG_FILE}
        exit 1
    fi

    # 1. Is mgmt_ip_A already added in /etc/hosts on node A?
    if grep -q "${mgmt_ip_A}" /etc/hosts ; then
        # 1.1 mgmt_ip_A is added in /etc/hosts
        if grep "${mgmt_ip_A}" /etc/hosts | grep "${hostname_A}"; then
            # mgmt_ip_A is added in /etc/hosts and is against hostname_A
            echo "DEBUG: Server A: /etc/hosts already has host entry for [server-A-IP  Server-A-hostname] -> [${mgmt_ip_A}) ${hostname_A}]" >> ${LOG_FILE}
            echo "Server A: host entry for Server A is up to date [${mgmt_ip_A}) ${hostname_A}]" | tee -a ${LOG_FILE}
        else
            # Entry for ${mgmt_ip_A} is there in /etc/hosts but it's not against hostname_A
            # Update the hostname against the existing entry.
            echo "Warning: Server A: host entry for Server A is not correct, trying to correct it."  | tee -a ${LOG_FILE}
            echo "DEBUG: Server A /etc/hosts already has entry for management IP (${mgmt_ip_A}) of server A (${hostname_A}) but against wrong/old hostname" >> ${LOG_FILE}
            # grab the current host added against mgmt_ip_A in /etc/hosts
            # replace the host with new hostname(hostname_A) against mgmt_ip_A
            _current_host=$(grep "${mgmt_ip_A}" /etc/hosts | awk '{ print $2 }')
            cat /etc/hosts | sed -e "s/${_current_host}/${hostname_A}/" > /tmp/hostsa-sed.tmp
            diff_lines=$(diff /etc/hosts /tmp/hostsa-sed.tmp | grep "<" | wc -l)
            #Check and ensure there is only one line change in the diff
            if [[ $diff_lines -eq 1 ]]; then
                # Only one line is changed, as expected.
                # Take backup of the original file
                if [[ ! -f /etc/hosts.orig ]]; then
                    # always take backup of original file as .orig & don't overwrite it
                    yes | cp -f /etc/hosts /etc/hosts.orig
                else
                    # overwrite the .bak file if present
                    yes | cp -f /etc/hosts /etc/hosts.bak
                fi
                # Replace the actual file with the file generated by sed with new ip
                yes | cp -f /tmp/hostsa-sed.tmp /etc/hosts
            elif [[ $diff_lines -eq 0 ]]; then
                # currnt host and hostname_A match, prbably due to rerun of 
                # the command or updating the pillar manually
                echo "Server A: host entry for Server A is up to date [${mgmt_ip_A}) ${hostname_A}]" | tee -a ${LOG_FILE}
            else
                # sed didn't work as expected (was supposed to change only one line)
                echo "ERROR: Could not update /etc/hosts on Server A with hostname ($hostname_A) and management IP of Sever A (${mgmt_ip_A})" | tee -a ${LOG_FILE}
                echo "ERROR: Please update /etc/hosts on Server A manually and run the command again" | tee -a ${LOG_FILE}
                exit 1
            fi
        fi
    else
        # 1.2 /etc/hosts does not have the entry, add it
        echo "Server A: Updating /etc/hosts with management IP (${mgmt_ip_A}) of server A (${hostname_A})" | tee -a  ${LOG_FILE}
        echo -e "\n${mgmt_ip_A} ${hostname_A}" >> /etc/hosts
        echo "Done" | tee -a ${LOG_FILE}
    fi

    # 2. Is mgmt_ip_B already added in /etc/hosts on node A?
    echo "DEBUG: Checking host entries in /etc/hosts on server A for management IP of Server B (${mgmt_ip_B})" >> ${LOG_FILE}
    if grep -q "${mgmt_ip_B}" /etc/hosts ; then
        # 2.1 mgmt_ip_B is added in /etc/hosts
        if grep "${mgmt_ip_B}" /etc/hosts | grep "${hostname_B}"; then
            # mgmt_ip_B is added in /etc/hosts and is against hostname_B
            echo "DEBUG: Server A: /etc/hosts already has host entry for management IP of server B (${mgmt_ip_B}) against hostname of Server B (${hostname_B})" >> ${LOG_FILE}
            echo "Server A: host entry for Server B is up to date [${mgmt_ip_B}) ${hostname_B}]" | tee -a ${LOG_FILE}
        else
            # Entry for ${mgmt_ip_B} is there in /etc/hosts but it's not against hostname_B
            # Update the hostname against the existing entry.
            echo "Warning: Server A: host entry for Server B is not correct, trying to correct it."  | tee -a ${LOG_FILE}
            echo "DEBUG: Server A: Warning: /etc/hosts already has entry for management IP (${mgmt_ip_B}) of server B (${hostname_B}) but against wrong/old hostname" >>  ${LOG_FILE}
            # grab the current host added against mgmt_ip_B in /etc/hosts
            # replace the current host with new hostname(hostname_B) against mgmt_ip_B
            _current_host=$(grep "${mgmt_ip_B}" /etc/hosts | awk '{ print $2 }')
            cat /etc/hosts | sed -e "s/${_current_host}/${hostname_B}/" > /tmp/hostsb-sed.tmp
            diff_lines=$(diff /etc/hosts /tmp/hostsb-sed.tmp | grep "<" | wc -l)
            #Check and ensure there is only one line change in the diff
            if [[ $diff_lines -eq 1 ]]; then
                # Only one line is changed, as expected.
                # Take backup of the original file
                if [[ ! -f /etc/hosts.orig ]]; then
                    # always take backup of original file as .orig & don't overwrite it
                    yes | cp -f /etc/hosts /etc/hosts.orig
                else
                    # overwrite the .bak file if present
                    yes | cp -f /etc/hosts /etc/hosts.bak
                fi
                # Replace the actual file with the file generated by sed with new ip
                yes | cp -f /tmp/hostsb-sed.tmp /etc/hosts
            elif [[ $diff_lines -eq 0 ]]; then
                # currnt host and hostname_B match, prbably due to rerun of 
                # the command or updating the pillar manually
                echo "Server A: host entry for Server B is up to date [${mgmt_ip_B}) ${hostname_B}]" | tee -a ${LOG_FILE}
            else
                # sed didn't work as expected (was supposed to change only one line)
                echo "ERROR: Could not update /etc/hosts on Server A with hostname (${hostname_B}) and management IP of Sever B (${mgmt_ip_B})" | tee -a ${LOG_FILE}
                echo "ERROR: Please update /etc/hosts on Server A manually and run the command again" | tee -a ${LOG_FILE}
                exit 1
            fi
        fi
    else
        # 2.2 /etc/hosts does not have the entry, add it
        echo "Server A: Updating /etc/hosts with management IP (${mgmt_ip_B}) of server B (${hostname_B})" | tee -a  ${LOG_FILE}
        echo -e "\n$mgmt_ip_B $hostname_B" >> /etc/hosts
        echo "Done" | tee -a ${LOG_FILE}
    fi

    # Repeat for node B
    echo "Checking /etc/hosts on Server B" | tee -a ${LOG_FILE}
    echo "DEBUG: Checking host entries in /etc/hosts on server B for management IP of node A (${mgmt_ip_A})" >> ${LOG_FILE}
    if $ssh_cmd ${pvt_ip_b} "stat /etc/hosts >/dev/null 2>&1"; then
        echo "DEBUG: /etc/hosts file is present on Server B" >> ${LOG_FILE}
    else
        echo "ERROR: /etc/hosts file not present on Server B. Please create the file manually and rerun the command." | tee -a ${LOG_FILE}
        exit 1
    fi
    # 1. Is mgmt_ip_A already added in /etc/hosts on node B?
    if $ssh_cmd ${pvt_ip_b} "grep -q \"${mgmt_ip_A}\" /etc/hosts" ; then
        # 1.1 mgmt_ip_A is added in /etc/hosts
        if $ssh_cmd ${pvt_ip_b} "grep \"${mgmt_ip_A}\" /etc/hosts | grep \"${hostname_A}\""; then
            # mgmt_ip_A is added in /etc/hosts and is against hostname_A
            echo "DEBUG: Server B: /etc/hosts already has host entry for management IP  of server A (${mgmt_ip_A}) against hostname of Server A (${hostname_A})" >> ${LOG_FILE}
            echo "Server B: host entry for Server A is up to date [${mgmt_ip_A}) ${hostname_A}]" | tee -a ${LOG_FILE}
        else
            # Entry for ${mgmt_ip_A} is there in /etc/hosts but it's not against hostname_A
            # Update the hostname against the existing entry.
            echo "DEBUG: Server B: Warning: /etc/hosts already has entry for management IP (${mgmt_ip_A}) of server A (${hostname_A}) but against wrong/old hostname" >>  ${LOG_FILE}
            echo "Warning: Server B: host entry for Server A is not correct, trying to correct it."  | tee -a ${LOG_FILE}
            # grab the current host added against mgmt_ip_A in /etc/hosts of Server A
            # replace the host with new hostname(hostname_A) against mgmt_ip_A
            _current_host=$($ssh_cmd ${pvt_ip_b} "grep "${mgmt_ip_A}" /etc/hosts" | awk '{ print $2 }')
            $ssh_cmd ${pvt_ip_b} "cat /etc/hosts | sed -e "s/${_current_host}/${hostname_A}/" > /tmp/hostsa-sed.tmp"
            diff_lines=$($ssh_cmd ${pvt_ip_b} "diff /etc/hosts /tmp/hostsa-sed.tmp" | grep "<" | wc -l)
            #Check and ensure there is only one line change in the diff
            if [[ $diff_lines -eq 1 ]]; then
                # Only one line is changed, as expected.
                # Take backup of the original file
                if $ssh_cmd ${pvt_ip_b} "stat /etc/hosts.orig >/dev/null 2>&1"; then
                    # always take backup of original file as .orig & don't overwrite it
                    $ssh_cmd ${pvt_ip_b} "yes | cp -f /etc/hosts /etc/hosts.orig"
                else
                    # overwrite the .bak file if present
                    $ssh_cmd ${pvt_ip_b} "yes | cp -f /etc/hosts /etc/hosts.bak"
                fi
                # Replace the actual file with the file generated by sed with new ip
                $ssh_cmd ${pvt_ip_b} "yes | cp -f /tmp/hostsa-sed.tmp /etc/hosts"
            elif [[ $diff_lines -eq 0 ]]; then
                # currnt host and hostname_A match, prbably due to rerun of 
                # the command or updating the pillar manually
                echo "Server B: host entry for Server A is up to date [${mgmt_ip_A}) ${hostname_A}]" | tee -a ${LOG_FILE}
            else
                # sed didn't work as expected (was supposed to change only one line)
                echo "ERROR: Could not update /etc/hosts on Server B with hostname (${hostname_A}) and management IP of Sever A (${mgmt_ip_A})" | tee -a ${LOG_FILE}
                echo "ERROR: Please update /etc/hosts on Server B manually and run the command again" | tee -a ${LOG_FILE}
                exit 1
            fi

        fi
    else
        # 1.2 /etc/hosts does not has the entry, add it
        echo "Server B: Updating /etc/hosts with management IP (${mgmt_ip_A}) of server A (${hostname_A})" | tee -a  ${LOG_FILE}
        echo -e "\n${mgmt_ip_A} ${hostname_A}" > /tmp/dns_a.tmp
        $scp_cmd /tmp/dns_a.tmp ${pvt_ip_b}:/tmp/dns_a.tmp
        $ssh_cmd ${pvt_ip_b} "cat /tmp/dns_a.tmp >> /etc/hosts" >> /etc/hosts
        echo "Done" | tee -a ${LOG_FILE}
    fi

    # Repeat for mgmt_ip_b on node B
    echo "Checking DNS entries in /etc/hosts on server B for management IP of node B (${mgmt_ip_B})" | tee -a ${LOG_FILE}
    # 2. Is mgmt_ip_B already added in /etc/hosts on node B?
    if $ssh_cmd ${pvt_ip_b} "grep -q \"${mgmt_ip_B}\" /etc/hosts" ; then
        # 2.1 mgmt_ip_B is added in /etc/hosts
        if $ssh_cmd ${pvt_ip_b} "grep \"${mgmt_ip_B}\" /etc/hosts | grep \"${hostname_B}\""; then
            # mgmt_ip_B is added in /etc/hosts and is against hostname_B
            echo "Server B: host entry for Server B is up to date [${mgmt_ip_B}) ${hostname_B}]" | tee -a ${LOG_FILE}
            echo "Server B: /etc/hosts already has dns entry for management IP  of server B (${mgmt_ip_B}) against hostname of Server B (${hostname_B})" | tee -a ${LOG_FILE}
        else
            # Entry for ${mgmt_ip_B} is there in /etc/hosts but it's not against hostname_B
            # Update the hostname against the existing entry.
            echo "DEBUG: Server B: Warning: /etc/hosts already has entry for management IP (${mgmt_ip_B}) of server B (${hostname_B}) but against wrong/old hostname" >>  ${LOG_FILE}
            echo "Warning: Server B: host entry for Server B is not correct, trying to correct it."  | tee -a ${LOG_FILE}

            # grab the current host added against mgmt_ip_B in /etc/hosts of Server B
            # replace the host with new hostname(hostname_B) against mgmt_ip_B
            _current_host=$($ssh_cmd ${pvt_ip_b} "grep "${mgmt_ip_B}" /etc/hosts" | awk '{ print $2 }')
            ${ssh_cmd} ${pvt_ip_b} "cat /etc/hosts | sed -e "s/${_current_host}/${hostname_B}/" > /tmp/hostsb-sed.tmp"
            diff_lines=$(${ssh_cmd} ${pvt_ip_b} "diff /etc/hosts /tmp/hostsb-sed.tmp" | grep "<" | wc -l)
            #Check and ensure there is only one line change in the diff
            if [[ $diff_lines -eq 1 ]]; then
                # Only one line is changed, as expected.
                # Take backup of the original file
                if $ssh_cmd ${pvt_ip_b} "stat /etc/hosts.orig >/dev/null 2>&1"; then
                    # always take backup of original file as .orig & don't overwrite it
                    $ssh_cmd ${pvt_ip_b} "yes | cp -f /etc/hosts /etc/hosts.orig"
                else
                    # overwrite the .bak file if present
                    $ssh_cmd ${pvt_ip_b} "yes | cp -f /etc/hosts /etc/hosts.bak"
                fi
                # Replace the actual file with the file generated by sed with new ip
                $ssh_cmd ${pvt_ip_b} "yes | cp -f /tmp/hostsb-sed.tmp /etc/hosts"
            elif [[ $diff_lines -eq 0 ]]; then
                # currnt host and hostname_B match, prbably due to rerun of 
                # the command or updating the pillar manually
                echo "The hostname of Server B is already present in /etc/hosts on Server B, ignoring" | tee -a ${LOG_FILE}
            else
                # sed didn't work as expected (was supposed to change only one line)
                echo "ERROR: Could not update /etc/hosts on Server B with hostname (${hostname_B}) and management IP of Sever B (${mgmt_ip_B})" | tee -a ${LOG_FILE}
                echo "ERROR: Please update /etc/hosts on Server B manually and run the command again" | tee -a ${LOG_FILE}
                exit 1
            fi
        fi
    else
        # 2.2 /etc/hosts does not has the entry, add it
        echo "Server B: Updating /etc/hosts with management IP (${mgmt_ip_B}) of server B (${hostname_B})" | tee -a  ${LOG_FILE}
        echo -e "\n${mgmt_ip_B} ${hostname_B}" > /tmp/dns_b.tmp
        $scp_cmd /tmp/dns_b.tmp ${pvt_ip_b}:/tmp/dns_b.tmp
        $ssh_cmd ${pvt_ip_b} "cat /tmp/dns_b.tmp >> /etc/hosts" >> /etc/hosts
        echo "Done" | tee -a ${LOG_FILE}
    fi
}

ssh_connectivity_check()
{
    ssh_A_to_B=false
    ssh_B_to_A=false

    # Check if the ssh works without password from Server A to Server B using DNS hostname
    echo "Checking passwordless ssh connectivity from Server A to Server B using new hostname" | tee -a ${LOG_FILE}
    if $ssh_cmd $hostname_B exit; then
        echo "SUCCESS: Passwordless ssh worked from Server A (${hostname_A}) to Server B (${hostname_B})"
        ssh_A_to_B=true
    else
        echo "ERROR: Could not connect Server B(${hostname_B}) from Server A(${hostname_A}) over ssh" | tee -a ${LOG_FILE}
        ssh_A_to_B=false
        return
    fi

    # Check if the ssh works without password from Server A to Server B using alias (srvnode-2)
     echo "Checking passwordless ssh connectivity from Server A to Server B using alias" | tee -a ${LOG_FILE}
     if ssh -q -o "ConnectTimeout=5" -o  "PreferredAuthentications=publickey" srvnode-2 "exit"; then
         echo "SUCCESS: Passwordless ssh worked from Server A to Server B alias (srvnode-2)" | tee -a ${LOG_FILE}
         ssh_A_to_B=true
     else
         echo "ERROR: Could not connect Server B(srvnode-2) from Server A over ssh using alias" | tee -a ${LOG_FILE}
         ssh_A_to_B=false
         return
     fi

    # Check if the ssh works without password from Server B to Server A using DNS hostname
    echo "Checking passwordless ssh connectivity from Server B to Server A using new hostname" | tee -a ${LOG_FILE}
    if $ssh_cmd ${hostname_B} \
        "ssh -q -o ConnectTimeout=5 -o PreferredAuthentications=publickey -o StrictHostKeyChecking=no ${hostname_A} exit; exit"; then
        echo "SUCCESS: Passwordless ssh worked from Server B ($hostname_B) to Server A ($hostname_A)"
        ssh_B_to_A=true
    else
        echo "ERROR: Could not connect Server A ($hostname_A) from Server B($hostname_B) over ssh" | tee -a ${LOG_FILE}
        ssh_B_to_A=false
    fi

    # Check if the ssh works without password from Server B to Server A using alias (srvnode-1)
     echo "Checking passwordless ssh connectivity from Server B to Server A using alias" | tee -a ${LOG_FILE}
     if ssh -q -o "ConnectTimeout=5" -o  "PreferredAuthentications=publickey" srvnode-2 \
         "ssh -q -o "ConnectTimeout=5" -o  "PreferredAuthentications=publickey" srvnode-1 exit; exit"; then
         echo "SUCCESS: Passwordless ssh worked from Server B (srvnode-2) to Server A (srvnode-1) using aliases" | tee -a ${LOG_FILE}
         ssh_B_to_A=true
     else
         echo "ERROR: Could not connect Server A(srvnode-1) from Server B(srvnode-2) over ssh using alias" | tee -a ${LOG_FILE}
         ssh_B_to_A=false
         return
     fi

}

ssh_config_update()
{
    # 1. Check if hostnames are up to date in ssh config, if yes, skip step 2.
    # 2. Update new hostnames in /root/.ssh/config file on Server A
    # 3. scp /root/.ssh/config file from Server A to Server B
    # 4. Check ssh connectivity from server A to server B using alias/minion id (srvnode-2)
    # 5. Check ssh connectivity from server B to server A using alias/minion id (srvnode-1)
    # 6. Check if the ssh works without password from Server A to Server B using hostname
    # 7. Check if the ssh works without password from Server B to Server A using hostname

    if [[ ! -f /root/.ssh/config ]]; then
        if [[ -f /opt/seagate/cortx/provisioner/files/.ssh/config ]]; then
            echo "DEBUG: Copying the ssh config file from Provisioner" >> ${LOG_FILE}
            yes | cp -f /opt/seagate/cortx/provisioner/files/.ssh/config /root/.ssh/config
        else
            echo "ERROR: ssh config file not present on Server A. Please create the file manually and rerun the command." | tee -a ${LOG_FILE}
            exit 1
        fi
    fi

    _update_ssh_conf_A=true
    if grep  "HostName" /root/.ssh/config | grep -q "$hostname_A"; then
        if grep "Host srvnode" /root/.ssh/config | grep -q "$hostname_A"; then
            echo "Hostname for Server A is already updated in ssh config file, skipping" | tee -a ${LOG_FILE}
            _update_ssh_conf_A=false
        fi
    fi

    _update_ssh_conf_B=true
    if grep  "HostName" /root/.ssh/config | grep -q "$hostname_B"; then
        if grep "Host srvnode" /root/.ssh/config | grep -q "$hostname_B"; then
            echo "Hostname for Server B is already updated in ssh config file, skipping" | tee -a ${LOG_FILE}
            _update_ssh_conf_B=false
        fi
    fi

    if [[ "$_update_ssh_conf_A" == true ]]; then
        # Replace Server A entry

        # take backup of ssh config file
        if [[ ! -f /root/.ssh/config.orig ]]; then
            # always keep the original copy with .orig 
            yes | cp -f /root/.ssh/config /root/.ssh/config.orig
        else
            # don't overwrite .orig copy, instead keep replacing .bak
            yes | cp -f /root/.ssh/config /root/.ssh/config.bak
        fi
        echo "Updating server A hostname (${hostname_A}) in ssh config file of server A" | tee -a ${LOG_FILE}
        local line_to_replace=$(grep -m1 -noP "HostName" /root/.ssh/config|tail -1|cut -d: -f1)
        sed -i "s|Host srvnode-1.*|Host srvnode-1 ${hostname_A}|" /root/.ssh/config
        sed -i "${line_to_replace}s|HostName.*|HostName ${hostname_A}|" /root/.ssh/config
        echo "Done" | tee -a ${LOG_FILE}
    fi

    if [[ "$_update_ssh_conf_B" == true ]]; then
        # Replace Server B entry
        echo "Updating server B hostname (${hostname_B}) in ssh config file of server A" | tee -a ${LOG_FILE}
        local line_to_replace=$(grep -m2 -noP "HostName" /root/.ssh/config|tail -1|cut -d: -f1)
        sed -i "s|Host srvnode-2.*|Host srvnode-2 ${hostname_B}|" /root/.ssh/config
        sed -i "${line_to_replace}s|HostName.*|HostName ${hostname_B}|" /root/.ssh/config
        echo "Done" | tee -a ${LOG_FILE}
    fi

    echo "Copying the ssh config file from Server A to Server B" | tee -a ${LOG_FILE}
    $scp_cmd /root/.ssh/config ${pvt_ip_b}:/root/.ssh/config
    echo "Done"

    # Check if the ssh works without password from Server A to Server B
    echo "Checking if the ssh works without password from Server A to Server B" | tee -a ${LOG_FILE}
    ssh -q -o "ConnectTimeout=5" srvnode-2 exit || {
        echo "ERROR: Server B is not reachable using alias (srvnode-2) over ssh" | tee -a ${LOG_FILE}
        exit 1
    }
    echo "Done." | tee -a ${LOG_FILE}
    # Check if the ssh works without password from Server B to Server A
    echo "Checking if the ssh works without password from Server B to Server A" | tee -a ${LOG_FILE}
    ssh -q -o "ConnectTimeout=5" srvnode-2 \
        "ssh -q -o ConnectTimeout=5 srvnode-1 exit; exit" || {
        echo "Server A is not reachable from Server B over ssh" | tee -a ${LOG_FILE}
        exit 1
    }
    echo "Done." | tee -a ${LOG_FILE}
}

minion_config_update()
{
    # 1. Update primary node hostname in /etc/salt/minion file with hostname of Server A 
    # 2. Update primary node hostname in /etc/salt/minion file with hostname of Server B 
    # 3. Restart salt-minion service on Server A
    # 4. Restart salt-minion service on Server B
    # 5. Restart salt-master service on Server A
    # 6. Check if 'salt '*' test.ping' works

    if [[ ! -f /etc/salt/minion ]]; then
        echo "ERROR: ssh config file not present on Server A. Please restore the file and rerun the command." | tee -a ${LOG_FILE}
        exit 1
    fi
    _update_minion_A=true
    if grep -w ^"master:" /etc/salt/minion | grep -q "$hostname_A"; then
        if grep "Host srvnode" /etc/salt/minion | grep -q "$hostname_A"; then
            echo "Hostname for Server A is already updated in salt config file, skipping" | tee -a ${LOG_FILE}
            _update_minion_A=false
        fi
    fi

    _update_minion_B=true
    if grep -w ^"master:" /etc/salt/minion | grep -q "$hostname_B"; then
        if grep "Host srvnode" /etc/salt/minion | grep -q "$hostname_B"; then
            echo "Hostname for Server B is already updated in salt config file, skipping" | tee -a ${LOG_FILE}
            _update_minion_B=false
        fi
    fi

    if [[ "$_update_minion_A" == true ]]; then
        local line_to_replace=$(grep -m1 -noP "master: " /etc/salt/minion|tail -1|cut -d: -f1)
        echo "Setting Salt primary node (${hostname_A}) on server A (${hostname_A})" | tee -a ${LOG_FILE}
        yes | cp -f /etc/salt/minion /etc/salt/minion.bkp
        sed -i "${line_to_replace}s|^master:.*|master: ${hostname_A}|" /etc/salt/minion
        echo "Done" | tee -a ${LOG_FILE}

        echo "Restarting salt-minion on Server A" | tee -a ${LOG_FILE}
        systemctl restart salt-minion
        echo "Done" | tee -a ${LOG_FILE}

        # Check if salt '*' test.ping works
        echo "Waiting for minion on Server A to become ready" | tee -a ${LOG_FILE}
        try=1; max_tries=10
        until salt -t 1 srvnode-1 test.ping >/dev/null 2>&1
        do
            if [[ "$try" -gt "$max_tries" ]]; then
                echo "
ERROR: minion srvnode-1 seems still not ready after $max_tries attempts.\
Check following things:
1. Restart salt-master service on Server A [systemctl restart salt-master]
2. Restart salt-minion service on Server A [systemctl restart salt-minion]
3. Restart salt-minion service on Server B [ssh srvnode-2 'systemctl restart salt-minion']
4. Check the status again [salt '*' test.ping]
5. If step 4 works, rerun the pre-unbox command
pre-unbox script did not run successfully, exiting." | tee -a ${LOG_FILE}
                #TODO: Retry after restarting services?
                exit 1
            fi
            echo -n "." | tee -a ${LOG_FILE}
            try=$(( $try + 1 ))
        done
        echo "Minion on Server A started successfully" | tee -a ${LOG_FILE}
    fi

    if [[ "$_update_minion_B" == true ]]; then
        echo "Setting (${hostname_A}) in Salt minion configuration on server B (${hostname_B})" | tee -a ${LOG_FILE}
        #TODO: Should we just scp minion file from Server A to server B?
        if $ssh_cmd ${pvt_ip_b} "stat /etc/salt/minion >/dev/null 2>&1"; then
            echo "DEBUG: Salt minion file present on Server B." >> ${LOG_FILE}
        else
            echo "ERROR: Salt minion file not present on Server B. Please restore the file and rerun the command." | tee -a ${LOG_FILE}
            exit 1
        fi
        line_to_replace=$($ssh_cmd ${pvt_ip_b} "grep -m1 -noP "master: " /etc/salt/minion" |tail -1|cut -d: -f1)
        yes | cp -f /etc/salt/minion /etc/salt/minion.bkp
        $ssh_cmd ${pvt_ip_b} "sed -i \"${line_to_replace}s|^master:.*|master: ${hostname_A}|\" /etc/salt/minion"
        echo "Done" | tee -a ${LOG_FILE}

        echo "Restarting salt-minion on Server B" | tee -a ${LOG_FILE}
        $ssh_cmd ${pvt_ip_b} "systemctl restart salt-minion"
        echo "Done" | tee -a ${LOG_FILE}
        sleep 5

        echo "Waiting for minion on Server B to become ready" | tee -a ${LOG_FILE}
        try=1; max_tries=10
        until salt -t 1 srvnode-2 test.ping >/dev/null 2>&1
        do
            if [[ "$try" -gt "$max_tries" ]]; then
                echo "
ERROR: minion srvnode-2 seems still not ready after $max_tries attempts.\
Check following things:
1. restart salt-master service on Server A [systemctl restart salt-master]
2. restart salt-minion service on Server A [systemctl restart salt-minion]
3. restart salt-minion service on Server B [ssh srvnode-2 'systemctl restart salt-minion']
4. check the status again [salt '*' test.ping]
5. if step 4 works, rerun the pre-unbox command
pre-unbox script did not run successfully, exiting." | tee -a ${LOG_FILE}
                #TODO: Retry after restarting services?
                exit 1
            fi
            echo -n "." | tee -a ${LOG_FILE}
            try=$(( $try + 1 ))
        done
        echo "Minion on Server B started successfully" | tee -a ${LOG_FILE}
    fi

}

pre_unbox()
{
    time_stamp=$(date)
    echo "******** [$time_stamp] Running $0 *********" >> ${LOG_FILE}
    #echo "*********************************************************" | tee -a ${LOG_FILE}
    #echo "          Unboxing the Cortx Lyve Drive Rack          " | tee -a ${LOG_FILE}
    #echo "*********************************************************" | tee -a ${LOG_FILE}

    echo "DEBUG: Capturing output of 'ip a' on Server A for analysis (if needed)." >> ${LOG_FILE}
    ip a >> ${LOG_FILE}

    echo "DEBUG: Capturing output of 'ip a' on Server B for analysis (if needed)." >> ${LOG_FILE}
    $ssh_cmd ${pvt_ip_b} "ip a" >> ${LOG_FILE}

    echo "DEBUG: Private IP address Node A: $pvt_ip_a" >> ${LOG_FILE}
    echo "DEBUG: Private IP address Node B: $pvt_ip_b" >> ${LOG_FILE}
    echo "DEBUG: default_hostname_nodeA: ${default_hostname_nodeA}" >> ${LOG_FILE}
    echo "DEBUG: default_hostname_nodeB: ${default_hostname_nodeB}" >> ${LOG_FILE}
    echo "DEBUG: nvols:$nvols ${default_hostname_nodeB}" >> ${LOG_FILE}
    echo "DEBUG: pillar_roots: ${pillar_root}" >> ${LOG_FILE}

    #1. Run cleanup 
    seagate_refs_cleanup

    #2. Check if the volumes are being listed on both the nodes - lsblk
    luns_availability_check

    #3. Get the controller IPs from user as an input
    #TODO: Remove this when enclosure communication is switched to in-band.
    #ctrl_ip_addr_get_set

    echo "Checking the servers connectivity" | tee -a ${LOG_FILE}
    hosts_resolution_check
    if [[ "${ping_status_A_to_B}" == false || "${ping_status_B_to_A}" == false || "${force_update_hname}" == true ]]; then
        #4. check if the hostname contains 'seagate.com', if yes, take input for new hostname
        echo "Servers are not reachable from each other, checking the hostnames" | tee -a ${LOG_FILE}
        hostname_validate_get_set
        echo "Checking the servers connectivity again after validating hostnames" | tee -a ${LOG_FILE}
        hosts_resolution_check
    fi

    if [[ "${ping_status_A_to_B}" == false || "${ping_status_B_to_A}" == false ]]; then
        #5. update hostnames in local dns (/etc/hosts)
        echo "Servers are not reachable from each other, checking if adding hosts entries in /etc/hosts helps" | tee -a ${LOG_FILE}
        dns_update_hostnames
        # Check the connectivity again after adding entries in /etc/hosts
        echo "Checking the servers connectivity again after adding entries in /etc/hosts" | tee -a ${LOG_FILE}
        hosts_resolution_check
        if [[ "${ping_status_A_to_B}" == false || "${ping_status_B_to_A}" == false ]]; then
            if [[ "$ping_status_A_to_B" == false ]]; then
                echo "ERROR: Server B (${hostname_B}) is not reachable from Server A (${hostname_A})" | tee -a ${LOG_FILE}
            elif [[ "${ping_status_B_to_A}" == false ]]; then
                echo "ERROR: Server A (${hostname_A}) is not reachable from Server B (${hostname_B})" | tee -a ${LOG_FILE}
            fi
            echo "Please ensure the servers are reachable from each other and rerun the command" | tee -a ${LOG_FILE}
            exit 1
        fi
    fi

    #6. Update hostnames in ssh config files
    ssh_connectivity_check
    if [[ "${ssh_A_to_B}" == false || "${ssh_B_to_A}" == false ]]; then
        ssh_config_update
    fi

    #7. Update minion files on both the nodes to point master to server A hostname
    # minion_config_update

    echo "DEBUG: pre_unbox script completed successfully" >> ${LOG_FILE}
}
